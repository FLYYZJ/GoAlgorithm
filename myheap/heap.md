# 二叉堆
- 性质：  
    堆中的某个节点总是不大于或不小于其父节点的值  
    堆总是一棵完全树   
    1. 最大堆： 父结点的键值总是大于或等于任何一个子节点的键值  
    2. 最小堆： 父结点的键值总是小于或等于任何一个子节点的键值

- 二叉堆用数组实现，当数组的第一个元素的索引为0表示时，此时有：  
    (01).  索引为i的左孩子的索引是 (2*i+1);  
    (02).  索引为i的右孩子的索引是 (2*i+2);  
    (03).  索引为i的父结点的索引是 floor((i-1)/2)  

- 参考
    https://www.cnblogs.com/henry-1202/p/9307927.html

# 左倾堆
左倾堆的每个节点有一个附加信息，即**null path length (npl)**。npl是从一个节点到一个最近的不满节点的路径长度(不满节点:两个子节点至少有一个为NULL)。一个叶节点的npl为0，一个NULL节点的npl为-1。
- npl特点：
    一个节点的npl等于子节点npl中最小值加1: npl(node) = min(npl(lchild), npl(rchild)) + 1
- 左倾堆特性：  
    **要求1**: 每个节点的优先级大于子节点的优先级。  
    **要求2**: 对于任意节点的左右两个子节点，右子节点的npl不大于左子节点的npl。
    
    左倾堆的任意子树也是左倾堆  
    如果一个左倾堆的右侧路径上有r个节点，那么该左倾堆将至少有2r-1个节点  

- 左倾堆合并操作
    沿着右侧路径进行左倾堆的合并操作。合并采用递归。合并如下:  
    (base case) 如果一个空左倾堆与一个非空左倾堆合并，返回非空左倾堆
    如果两个左倾堆都非空，那么比较两个根节点。取较小的根节点为新的根节点(满足要求1)，合并较小根节点堆的右子堆与较大根节点堆。
    如果右子堆npl > 左子堆npl，互换右子堆与左子堆。
    更新根节点的npl = 右子堆npl + 1




- 参考：
    https://www.cnblogs.com/vamei/archive/2013/04/19/2978555.html

# 斜堆
类似于左倾堆，但是没有NPL(零距离)概念，合并操作时间复杂度为O(logn)，合并操作的一般流程为：

1. 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。
2. 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将"较小堆的根节点的右孩子"和"较大堆"进行合并。
3. 合并后，交换新堆根节点的左孩子和右孩子。

# 二项堆
二项堆是一个链表格式的数据结构，链表的每个元素都是一棵二项树（且为最小堆）。

## 二项树(二项树的子树也是二项树)
二项树是一种递归定义的有序树。它的递归定义如下：  
    (01) 二项树B0只有一个结点；  
    (02) 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子  

![](..\img\binomial_heap_1.jpg)  
上图的B0、B1、B2、B3、B4都是二项树。对比前面提到的二项树的定义：B0只有一个节点，B1由两个B0所组成，B2由两个B1所组成，B3由两个B2所组成，B4由两个B3所组成；而且，当两颗相同的二项树组成另一棵树时，其中一棵树是另一棵树的最左孩子  

二项树性质
- Bk共有2^k个节点。
- Bk的高度为k(树的高度和深度是相同的)
- Bk在深度i处恰好有C(k,i)个节点(就是统计学里的那个概念)，其中i=0,1,2,...,k
- 根的度数为k，它大于任何其它节点的度数

## 二项堆（二项树的集合）
- 二项堆定义  
    (01) 每棵二项树都满足最小堆性质。即，父节点的关键字 <= 它的孩子的关键字。  
    (02) 不能有两棵或以上的二项树具有相同的度数(包括度数为0，度是指其含有的子树的个数，或者是说含有的子节点的个数)。换句话说，具有度数k的二项树有0个或1个。  
    ![](..\img\binomial_heap_2.jpg)   

- 二项堆合并流程（比较重要的操作，插入和删除操作的关键）：  
    (01) 将两个二项堆的根链表合并成一个链表。合并后的新链表按照"节点的度数"单调递增排列。  
    (02) 将新链表中"根节点度数相同的二项树"连接起来，直到所有根节点度数都不相同。
    ![](..\img\binomial_heap_2.jpg)   


- 二项堆删除流程（把节点移到其所在二项树的根，然后删除并移除该二项树，然后对二项树进行重组，重新插入二项堆中）  
    (01) 将"该节点"交换到"它所在二项树"的根节点位置。方法是，从"该节点"不断向上(即向树根方向)"遍历，不断交换父节点和子节点的数据，直到被删除的键值到达树根位置。  
    (02) 将"该节点所在的二项树"从二项堆中移除；将该二项堆记为heap。  
    (03) 将"该节点所在的二项树"进行反转。反转的意思，就是将根的所有孩子独立出来，并将这些孩子整合成二项堆，将该二项堆记为child。  
    (04) 将child和heap进行合并操作。  